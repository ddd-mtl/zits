#![allow(unused_doc_comments)]

mod to_typescript;
mod typescript;
pub mod utils;
pub(crate) mod casing;
pub(crate) mod zome_proxy;
pub(crate) mod holochain_imports;
mod parser;


use std::fs::File;
use std::io::{BufRead, BufReader, Write};
use std::path::{Path, PathBuf};
use walkdir::WalkDir;
use crate::parser::*;
use crate::zome_proxy::{write_type_defs_header, write_zome_proxy_header};


const MAGIC_FIRST_LINE: &str = "/* This file is generated by zits. Do not edit manually */";


pub struct GenConfig {
    can_debug: bool,
    can_proxy: bool,
    can_hc_imports: bool,
    uses_typeinterface: bool,
}


///
pub fn generate_typescript_bindings(input: Vec<PathBuf>, output: PathBuf, debug: bool) {

    let uses_typeinterface = output
        .as_os_str()
        .to_str()
        .map(|x| x.ends_with(".d.ts"))
        .unwrap_or(true);


    let mut state: ParseState = ParseState {
        unprocessed_files: Vec::<PathBuf>::new(),
        type_defs_output: String::new(),
        zome_proxy_output: String::new(),
        config: GenConfig {
            can_debug: debug,
            can_proxy: true,
            can_hc_imports: true,
            uses_typeinterface,
        },
    };


    let file_name = output.file_stem().unwrap().to_str().unwrap();
    let zome_name: &str = file_name.split(".").collect::<Vec<&str>>()[0];

    write_type_defs_header(&mut state.type_defs_output);
    write_zome_proxy_header(&mut state.zome_proxy_output, &output, &zome_name);



    /// Parse input files
    for input_path in input {
        if !input_path.exists() {
            if debug {
                println!("Path `{:#?}` does not exist", input_path);
            }

            state.unprocessed_files.push(input_path);
            continue;
        }

        if input_path.is_dir() {
            for entry in WalkDir::new(input_path.clone()).sort_by_file_name() {
                match entry {
                    Ok(dir_entry) => {
                        let path = dir_entry.into_path();

                        // skip dir files because they're going to be recursively crawled by WalkDir
                        if !path.is_dir() {
                            // make sure it is a rust file
                            let extension = path.extension();
                            if extension.is_some() && extension.unwrap().eq_ignore_ascii_case("rs")
                            {
                                state.parse_rust_file(path);
                            } else if debug {
                                println!("Encountered non-rust file `{:#?}`", path);
                            }
                        } else if debug {
                            println!("Encountered directory `{:#?}`", path);
                        }
                    }
                    Err(_) => {
                        println!(
                            "An error occurred whilst walking directory `{:#?}`...",
                            input_path.clone()
                        );
                        continue;
                    }
                }
            }
        } else {
            state.parse_rust_file(input_path);
        }
    }


    /// Proxy file footer and write to disk
    state.zome_proxy_output.push_str(&format!("}}\n"));

    /** */
    if debug {
        println!("\n");
        println!("======================================");
        println!("FINAL TYPES FILE:");
        println!("======================================");
        println!("{}", state.type_defs_output);
        println!("======================================");
        println!("FINAL FN FILE:");
        println!("======================================");
        println!("{}", state.zome_proxy_output);
        println!("======================================");
        println!("Note: Nothing is written in debug mode");
        println!("======================================");
    } else {
        // Verify that the output file either doesn't exists or has been generated by zits.
        let original_file_path = Path::new(&output);
        if original_file_path.exists() {
            if !original_file_path.is_file() {
                panic!("Specified output path is a directory but must be a file.")
            }
            let original_file = File::open(original_file_path).expect("Couldn't open output file");
            let mut buffer = BufReader::new(original_file);

            let mut first_line = String::new();

            buffer
                .read_line(&mut first_line)
                .expect("Unable to read line");

            if first_line.trim() != MAGIC_FIRST_LINE {
                panic!("Aborting: specified output file exists but doesn't seem to be a zits output file: {}", first_line)
            }
        }

        let mut file: File = File::create(&output).expect("Unable to write to file");
        match file.write_all(state.type_defs_output.as_bytes()) {
            Ok(_) => println!("[zits][info] Successfully generated typescript bindings: {:#?}", output),
            Err(_) => println!("Failed to generate types, an error occurred."),
        }

        /// Proxy file
        let mut proxy_output: PathBuf = output.clone();
        proxy_output.set_file_name(format!("{}.proxy.ts", zome_name));
        //println!("ProxyFile: {:?}", proxy_output);
        let mut proxy_file: File = File::create(&proxy_output).expect("Unable to write to file");
        match proxy_file.write_all(state.zome_proxy_output.as_bytes()) {
            Ok(_) => println!("[zits][info] Successfully generated ZomeProxy: {:#?}", proxy_output),
            Err(_) => println!("Failed to generate ZomeProxy, an error occurred."),
        }

    }

    if state.unprocessed_files.len() > 0 {
        println!("[zits][info] Could not parse the following files:");
        for unprocessed_file in state.unprocessed_files {
            println!("â€¢ {:#?}", unprocessed_file);
        }
    }
}
